// Code generated by antlr2participle. DO NOT EDIT.
package capnproto

import (
	"github.com/alecthomas/participle/v2"
	"github.com/alecthomas/participle/v2/lexer"
)

var (
	Rules = lexer.Rules{
		"Root": {
			{"LOCATOR", `@([0-9])+!?`, nil},
			{"TEXT", `"[^"]*?"`, nil},
			{"INTEGER", `-?([0-9])+`, nil},
			{"FLOAT", `-?([0-9])+(\.([0-9])+)?(e-?([0-9])+)?`, nil},
			{"HEXADECIMAL", `-?0x([0-9]|[A-F]|[a-f])+`, nil},
			{"FILE_ID", `@-?0x([0-9]|[A-F]|[a-f])+`, nil},
			{"BOOLEAN", `(true|false)`, nil},
			{"VOID", `void`, nil},
			{"NAME", `[a-zA-Z][a-zA-Z0-9]*`, nil},
			{"comment", `#[^\n]*`, nil},
			{"whitespace", `[ \t\r\n]`, nil},
			{"XXX__LITERAL_Dollar", `\$`, nil},
			{"XXX__LITERAL_Lparen", `\(`, nil},
			{"XXX__LITERAL_Rparen", `\)`, nil},
			{"XXX__LITERAL_Comma", `,`, nil},
			{"XXX__LITERAL_Minus", `-`, nil},
			{"XXX__LITERAL_MinusGt", `->`, nil},
			{"XXX__LITERAL_Stop", `\.`, nil},
			{"XXX__LITERAL_StopAnn", `\.ann`, nil},
			{"XXX__LITERAL_StopNamespace", `\.namespace`, nil},
			{"XXX__LITERAL_0X", `0x`, nil},
			{"XXX__LITERAL_Colon", `:`, nil},
			{"XXX__LITERAL_ColonGroup", `:group`, nil},
			{"XXX__LITERAL_ColonUnion", `:union`, nil},
			{"XXX__LITERAL_Semi", `;`, nil},
			{"XXX__LITERAL_Eq", `=`, nil},
			{"XXX__LITERAL_Lbkt", `\[`, nil},
			{"XXX__LITERAL_Rbkt", `\]`, nil},
			{"XXX__LITERAL_Annotation", `annotation`, nil},
			{"XXX__LITERAL_Const", `const`, nil},
			{"XXX__LITERAL_Enum", `enum`, nil},
			{"XXX__LITERAL_Extends", `extends`, nil},
			{"XXX__LITERAL_Import", `import`, nil},
			{"XXX__LITERAL_Interface", `interface`, nil},
			{"XXX__LITERAL_Struct", `struct`, nil},
			{"XXX__LITERAL_Union", `union`, nil},
			{"XXX__LITERAL_Using", `using`, nil},
			{"XXX__LITERAL_Lbrc", `\{`, nil},
			{"XXX__LITERAL_Rbrc", `\}`, nil},
		},
	}
	Lexer  = lexer.MustStateful(Rules, lexer.MatchLongest())
	Parser = participle.MustBuild(
		&Document{},
		participle.Lexer(Lexer),
		participle.UseLookahead(2),
	)
)

type Document struct {
	FileIdentifier  *FileIdentifier    `@@`
	UsingImport     []*UsingImport     `@@*`
	Namespace       *Namespace         `@@?`
	DocumentContent []*DocumentContent `@@* EOF`
}
type FileIdentifier struct {
	FileId *string `@FILE_ID ';'`
}
type UsingImport struct {
	Name  *string `'using' ( @NAME '=' )?`
	Text  *string `'import' @TEXT`
	Name2 *string `( '.' @NAME )? ';'`
}
type Namespace struct {
	Name *string `'$' @NAME`
	Text *string `'.namespace' '(' @TEXT ')' ';'`
}
type DocumentContent struct {
	StructDef     *StructDef     `@@`
	InterfaceDef  *InterfaceDef  `| @@`
	FunctionDef   *FunctionDef   `| @@`
	AnnotationDef *AnnotationDef `| @@`
	ConstDef      *ConstDef      `| @@`
	EnumDef       *EnumDef       `| @@`
}
type StructDef struct {
	Type                *Type                `'struct' @@`
	AnnotationReference *AnnotationReference `@@?`
	StructContent       []*StructContent     `'{' @@* '}'`
}
type StructContent struct {
	FieldDef        *FieldDef        `@@`
	EnumDef         *EnumDef         `| @@`
	NamedUnionDef   *NamedUnionDef   `| @@`
	UnnamedUnionDef *UnnamedUnionDef `| @@`
	InterfaceDef    *InterfaceDef    `| @@`
	AnnotationDef   *AnnotationDef   `| @@`
	StructDef       *StructDef       `| @@`
	GroupDef        *GroupDef        `| @@`
	ConstDef        *ConstDef        `| @@`
	InnerUsing      *InnerUsing      `| @@`
}
type InterfaceDef struct {
	Type             *Type               `'interface' @@`
	Type2            *Type               `( 'extends' '(' @@ ')' )?`
	InterfaceContent []*InterfaceContent `'{' @@* '}'`
}
type InterfaceContent struct {
	FieldDef        *FieldDef        `@@`
	EnumDef         *EnumDef         `| @@`
	NamedUnionDef   *NamedUnionDef   `| @@`
	UnnamedUnionDef *UnnamedUnionDef `| @@`
	InterfaceDef    *InterfaceDef    `| @@`
	StructDef       *StructDef       `| @@`
	FunctionDef     *FunctionDef     `| @@`
}
type FieldDef struct {
	Name       *string     `@NAME`
	Locator    *string     `@LOCATOR`
	Type       *Type       `':' @@`
	ConstValue *ConstValue `( '=' @@ )? ';'`
}
type Type struct {
	Name      *string    `@NAME`
	InnerType *InnerType `@@?`
	Type      *Type      `( '.' @@ )?`
}
type InnerType struct {
	Type          *Type            `'(' @@`
	InnerType     *InnerType       `@@?`
	TypeInnerType []*TypeInnerType `@@* ')'`
}
type TypeInnerType struct {
	Type      *Type      `',' @@`
	InnerType *InnerType `@@?`
}
type EnumDef struct {
	Name                *string              `'enum' @NAME`
	AnnotationReference *AnnotationReference `@@?`
	EnumContent         []*EnumContent       `'{' @@* '}'`
}
type AnnotationReference struct {
	Type *Type   `'$' @@`
	Text *string `'.ann'? '(' @TEXT ')'`
}
type EnumContent struct {
	Name                *string              `@NAME`
	Locator             *string              `@LOCATOR`
	AnnotationReference *AnnotationReference `@@? ';'`
}
type NamedUnionDef struct {
	Name         *string         `@NAME`
	Locator      *string         `@LOCATOR?`
	UnionContent []*UnionContent `':union' '{' @@* '}'`
}
type UnnamedUnionDef struct {
	UnionContent []*UnionContent `'union' '{' @@* '}'`
}
type UnionContent struct {
	FieldDef        *FieldDef        `@@`
	GroupDef        *GroupDef        `| @@`
	UnnamedUnionDef *UnnamedUnionDef `| @@`
	NamedUnionDef   *NamedUnionDef   `| @@`
}
type GroupDef struct {
	Name         *string         `@NAME`
	GroupContent []*GroupContent `':group' '{' @@* '}'`
}
type GroupContent struct {
	FieldDef        *FieldDef        `@@`
	UnnamedUnionDef *UnnamedUnionDef `| @@`
	NamedUnionDef   *NamedUnionDef   `| @@`
}
type FunctionDef struct {
	Name                  *string                `@NAME`
	Locator               *string                `@LOCATOR?`
	GenericTypeParameters *GenericTypeParameters `@@?`
	FunctionParameters    *FunctionParameters    `( @@`
	Type                  *Type                  `| @@ )`
	FunctionParameters2   *FunctionParameters    `( '->' ( @@`
	Type2                 *Type                  `| @@ ) )? ';'`
}
type GenericTypeParameters struct {
	Name  *string   `'[' @NAME`
	Name2 []*string `( ',' @NAME )* ']'`
}
type FunctionParameters struct {
	Name               *string               `'(' ( @NAME`
	Type               *Type                 `':' @@`
	ConstValue         *ConstValue           `( '=' @@ )?`
	NameTypeConstValue []*NameTypeConstValue `@@* )? ')'`
}
type NameTypeConstValue struct {
	Name       *string     `',' @NAME`
	Type       *Type       `':' @@`
	ConstValue *ConstValue `( '=' @@ )?`
}
type AnnotationDef struct {
	Type                 *Type                 `'annotation' @@`
	AnnotationParameters *AnnotationParameters `@@?`
	Type2                *Type                 `':' @@ ';'`
}
type AnnotationParameters struct {
	LparenStructRparen bool `@( '(' 'struct' ')' )`
}
type ConstDef struct {
	Name       *string     `'const' @NAME`
	Type       *Type       `':' @@`
	ConstValue *ConstValue `'=' @@ ';'`
}
type ConstValue struct {
	Name         *string       `'-'? '.'? @NAME`
	Name2        *string       `( '.' @NAME )?`
	Integer      *string       `| @INTEGER`
	Float        *string       `| @FLOAT`
	Text         *string       `| @TEXT`
	Boolean      *string       `| @BOOLEAN`
	Hexadecimal  *string       `| @HEXADECIMAL`
	Void         *string       `| @VOID`
	LiteralList  *LiteralList  `| @@`
	LiteralUnion *LiteralUnion `| @@`
	LiteralBytes *LiteralBytes `| @@`
}
type LiteralUnion struct {
	Name             *string             `'(' @NAME`
	UnionMapping     *UnionMapping       `'=' @@`
	NameUnionMapping []*NameUnionMapping `@@* ')'`
}
type NameUnionMapping struct {
	Name         *string       `',' @NAME`
	UnionMapping *UnionMapping `'=' @@`
}
type LiteralList struct {
	ConstValue []*ConstValue `'[' @@ ( ',' @@ )* ']'`
}
type LiteralBytes struct {
	Text *string `'0x' @TEXT`
}
type UnionMapping struct {
	Name        *string     `'(' @NAME`
	ConstValue  *ConstValue `'=' @@ ')'`
	ConstValue2 *ConstValue `| @@`
}
type InnerUsing struct {
	Name  *string   `'using' @NAME`
	Name2 []*string `( '.' @NAME )*`
	Type  *Type     `( '=' @@ )? ';'`
}
