
// Code generated by Participle. DO NOT EDIT.
package lexer_test

import (
	"io"
	"regexp"
	"strings"
	"sync"
	"unicode/utf8"

	"github.com/alecthomas/participle/v2"
	"github.com/alecthomas/participle/v2/lexer"
)

var (
	Lexer lexer.Definition = definitionImpl{}
	backrefCache sync.Map
	codegenBackrefRe = regexp.MustCompile(`\\+\d`)
)

type definitionImpl struct {}

func (definitionImpl) Symbols() map[string]lexer.TokenType {
	return map[string]lexer.TokenType{
		"Comment": -7,
		"EOF": -1,
		"EOL": -6,
		"Ident": -4,
		"Number": -3,
		"Punct": -5,
		"String": -2,
		"Whitespace": -8,
	}
}

func (definitionImpl) LexString(filename string, s string) (lexer.Lexer, error) {
	return &lexerImpl{
		s: s,
		pos: lexer.Position{
			Filename: filename,
			Line:     1,
			Column:   1,
		},
		states: []lexerState{ {name: "Root"} },
	}, nil
}

func (d definitionImpl) LexBytes(filename string, b []byte) (lexer.Lexer, error) {
	return d.LexString(filename, string(b))
}

func (d definitionImpl) Lex(filename string, r io.Reader) (lexer.Lexer, error) {
	s := &strings.Builder{}
	_, err := io.Copy(s, r)
	if err != nil {
		return nil, err
	}
	return d.LexString(filename, s.String())
}

type lexerState struct {
	name    string
	groups  []string
}

type lexerImpl struct {
	s       string
	pos     lexer.Position
	states  []lexerState
}

// https://github.com/golang/go/issues/31666
func decodeRune(p string) (r rune, size int) {
	if len(p) > 0 && p[0] < utf8.RuneSelf {
		return rune(p[0]), 1
	}
	return utf8.DecodeRuneInString(p)
}


func (l *lexerImpl) Next() (lexer.Token, error) {
	if l.s == "" {
		return lexer.EOFToken(l.pos), nil
	}
	var (
		state = l.states[len(l.states)-1]
		groups []int
		sym lexer.TokenType
	)
	switch state.name {

	case "Root":if match := matchString(state.groups, l.s); match[0] == 0 && match[1] != 0 {
			groups = match[:]
			sym = -2
		} else if match := matchNumber(state.groups, l.s); match[0] == 0 && match[1] != 0 {
			groups = match[:]
			sym = -3
		} else if match := matchIdent(state.groups, l.s); match[0] == 0 && match[1] != 0 {
			groups = match[:]
			sym = -4
		} else if match := matchPunct(state.groups, l.s); match[0] == 0 && match[1] != 0 {
			groups = match[:]
			sym = -5
		} else if match := matchEOL(state.groups, l.s); match[0] == 0 && match[1] != 0 {
			groups = match[:]
			sym = -6
		} else if match := matchComment(state.groups, l.s); match[0] == 0 && match[1] != 0 {
			groups = match[:]
			sym = -7
		} else if match := matchWhitespace(state.groups, l.s); match[0] == 0 && match[1] != 0 {
			groups = match[:]
			sym = -8
		}
	}
	if groups == nil {
		sample := []rune(l.s)
		if len(sample) > 16 {
			sample = append(sample[:16], []rune("...")...)
		}
		return lexer.Token{}, participle.Errorf(l.pos, "invalid input text %q", string(sample))
	}
	pos := l.pos
	span := l.s[:groups[1]]
	l.s = l.s[groups[1]:]
	l.pos.Advance(span)
	return lexer.Token{
		Type:  sym,
		Value: span,
		Pos:   pos,
	}, nil
}


// "(\\"|[^"])*"
func matchString(groups []string, s string) (matches [4]int) {
p := 0
// " (Literal)
l0 := func(s string, p int) int {
if p < len(s) && s[p] == '"' { return p+1 }
return -1
}
// \\" (Literal)
l1 := func(s string, p int) int {
if p+2 < len(s) && s[p:p+2] == "\\\"" { return p+2 }
return -1
}
// [^"] (CharClass)
l2 := func(s string, p int) int {
if len(s) <= p { return -1 }
var (rn rune; n int)
if s[p] < utf8.RuneSelf {
  rn, n = rune(s[p]), 1
} else {
  rn, n = utf8.DecodeRuneInString(s[p:])
}
switch {
case rn >= '\x00' && rn <= '!': return p+1
case rn >= '#' && rn <= '\U0010ffff': return p+n
}
return -1
}
// \\"|[^"] (Alternate)
l3 := func(s string, p int) int {
if np := l1(s, p); np != -1 { return np }
if np := l2(s, p); np != -1 { return np }
return -1
}
// (\\"|[^"]) (Capture)
l4 := func(s string, p int) int {
np := l3(s, p)
if np != -1 {
  matches[2] = p
  matches[3] = np
}
return np}
// (\\"|[^"])* (Star)
l5 := func(s string, p int) int {
for len(s) > p {
if np := l4(s, p); np == -1 { return p } else { p = np }
}
return p
}
// "(\\"|[^"])*" (Concat)
l6 := func(s string, p int) int {
if p = l0(s, p); p == -1 { return -1 }
if p = l5(s, p); p == -1 { return -1 }
if p = l0(s, p); p == -1 { return -1 }
return p
}
np := l6(s, p)
if np == -1 {
  return
}
matches[0] = p
matches[1] = np
return
}

// [\+\-]?([0-9]*\.)?[0-9]+
func matchNumber(groups []string, s string) (matches [4]int) {
p := 0
// [\+\-] (CharClass)
l0 := func(s string, p int) int {
if len(s) <= p { return -1 }
rn := s[p]
switch {
case rn == '+': return p+1
case rn == '-': return p+1
}
return -1
}
// [\+\-]? (Quest)
l1 := func(s string, p int) int {
if np := l0(s, p); np != -1 { return np }
return p
}
// [0-9] (CharClass)
l2 := func(s string, p int) int {
if len(s) <= p { return -1 }
rn := s[p]
switch {
case rn >= '0' && rn <= '9': return p+1
}
return -1
}
// [0-9]* (Star)
l3 := func(s string, p int) int {
for len(s) > p {
if np := l2(s, p); np == -1 { return p } else { p = np }
}
return p
}
// \. (Literal)
l4 := func(s string, p int) int {
if p < len(s) && s[p] == '.' { return p+1 }
return -1
}
// [0-9]*\. (Concat)
l5 := func(s string, p int) int {
if p = l3(s, p); p == -1 { return -1 }
if p = l4(s, p); p == -1 { return -1 }
return p
}
// ([0-9]*\.) (Capture)
l6 := func(s string, p int) int {
np := l5(s, p)
if np != -1 {
  matches[2] = p
  matches[3] = np
}
return np}
// ([0-9]*\.)? (Quest)
l7 := func(s string, p int) int {
if np := l6(s, p); np != -1 { return np }
return p
}
// [0-9]+ (Plus)
l8 := func(s string, p int) int {
if p = l2(s, p); p == -1 { return -1 }
for len(s) > p {
if np := l2(s, p); np == -1 { return p } else { p = np }
}
return p
}
// [\+\-]?([0-9]*\.)?[0-9]+ (Concat)
l9 := func(s string, p int) int {
if p = l1(s, p); p == -1 { return -1 }
if p = l7(s, p); p == -1 { return -1 }
if p = l8(s, p); p == -1 { return -1 }
return p
}
np := l9(s, p)
if np == -1 {
  return
}
matches[0] = p
matches[1] = np
return
}

// [A-Z_a-z][0-9A-Z_a-z]*
func matchIdent(groups []string, s string) (matches [2]int) {
p := 0
// [A-Z_a-z] (CharClass)
l0 := func(s string, p int) int {
if len(s) <= p { return -1 }
rn := s[p]
switch {
case rn >= 'A' && rn <= 'Z': return p+1
case rn == '_': return p+1
case rn >= 'a' && rn <= 'z': return p+1
}
return -1
}
// [0-9A-Z_a-z] (CharClass)
l1 := func(s string, p int) int {
if len(s) <= p { return -1 }
rn := s[p]
switch {
case rn >= '0' && rn <= '9': return p+1
case rn >= 'A' && rn <= 'Z': return p+1
case rn == '_': return p+1
case rn >= 'a' && rn <= 'z': return p+1
}
return -1
}
// [0-9A-Z_a-z]* (Star)
l2 := func(s string, p int) int {
for len(s) > p {
if np := l1(s, p); np == -1 { return p } else { p = np }
}
return p
}
// [A-Z_a-z][0-9A-Z_a-z]* (Concat)
l3 := func(s string, p int) int {
if p = l0(s, p); p == -1 { return -1 }
if p = l2(s, p); p == -1 { return -1 }
return p
}
np := l3(s, p)
if np == -1 {
  return
}
matches[0] = p
matches[1] = np
return
}

// [!-/:-@\[-`\{-~]+
func matchPunct(groups []string, s string) (matches [2]int) {
p := 0
// [!-/:-@\[-`\{-~] (CharClass)
l0 := func(s string, p int) int {
if len(s) <= p { return -1 }
rn := s[p]
switch {
case rn >= '!' && rn <= '/': return p+1
case rn >= ':' && rn <= '@': return p+1
case rn >= '[' && rn <= '`': return p+1
case rn >= '{' && rn <= '~': return p+1
}
return -1
}
// [!-/:-@\[-`\{-~]+ (Plus)
l1 := func(s string, p int) int {
if p = l0(s, p); p == -1 { return -1 }
for len(s) > p {
if np := l0(s, p); np == -1 { return p } else { p = np }
}
return p
}
np := l1(s, p)
if np == -1 {
  return
}
matches[0] = p
matches[1] = np
return
}

// \n
func matchEOL(groups []string, s string) (matches [2]int) {
p := 0
if p < len(s) && s[p] == '\n' {
matches[0] = p
matches[1] = p + 1
}
return
}

// (?i:REM)[^\n]*(?i:\n)
func matchComment(groups []string, s string) (matches [2]int) {
p := 0
// (?i:REM) (Literal)
l0 := func(s string, p int) int {
if p+3 < len(s) && s[p:p+3] == "REM" { return p+3 }
return -1
}
// [^\n] (CharClass)
l1 := func(s string, p int) int {
if len(s) <= p { return -1 }
var (rn rune; n int)
if s[p] < utf8.RuneSelf {
  rn, n = rune(s[p]), 1
} else {
  rn, n = utf8.DecodeRuneInString(s[p:])
}
switch {
case rn >= '\x00' && rn <= '\t': return p+1
case rn >= '\v' && rn <= '\U0010ffff': return p+n
}
return -1
}
// [^\n]* (Star)
l2 := func(s string, p int) int {
for len(s) > p {
if np := l1(s, p); np == -1 { return p } else { p = np }
}
return p
}
// (?i:\n) (Literal)
l3 := func(s string, p int) int {
if p < len(s) && s[p] == '\n' { return p+1 }
return -1
}
// (?i:REM)[^\n]*(?i:\n) (Concat)
l4 := func(s string, p int) int {
if p = l0(s, p); p == -1 { return -1 }
if p = l2(s, p); p == -1 { return -1 }
if p = l3(s, p); p == -1 { return -1 }
return p
}
np := l4(s, p)
if np == -1 {
  return
}
matches[0] = p
matches[1] = np
return
}

// [\t ]+
func matchWhitespace(groups []string, s string) (matches [2]int) {
p := 0
// [\t ] (CharClass)
l0 := func(s string, p int) int {
if len(s) <= p { return -1 }
rn := s[p]
switch {
case rn == '\t': return p+1
case rn == ' ': return p+1
}
return -1
}
// [\t ]+ (Plus)
l1 := func(s string, p int) int {
if p = l0(s, p); p == -1 { return -1 }
for len(s) > p {
if np := l0(s, p); np == -1 { return p } else { p = np }
}
return p
}
np := l1(s, p)
if np == -1 {
  return
}
matches[0] = p
matches[1] = np
return
}
