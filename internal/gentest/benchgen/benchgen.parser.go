// Code generated by Participle. DO NOT EDIT.

package benchgen

import (
		"strconv"

		"github.com/alecthomas/participle/v2"
		"github.com/alecthomas/participle/v2/lexer"
	)

func (p *AST) Parse(lex *lexer.PeekingLexer) error {
  tokens, err := parse0(lex, p)
  if err != nil { return err }
  if tokens == nil {
    tok, _ := lex.Peek(0)
    if tok.EOF() { return nil }
    return participle.UnexpectedTokenError{tok, ""}
  }
  return nil
}

// AST = Entry* . (strct)
func parse0(lex *lexer.PeekingLexer, owner *AST) ([]string, error) {
  tokens, err := parse1(lex, owner)
  if err != nil || tokens == nil { return nil, err }
  return tokens, nil
}

// Entry* (group)
func parse1(lex *lexer.PeekingLexer, owner *AST) ([]string, error) {
  var ( matches int; tokens []string )
  for {
    sub, err := parse2(lex, owner)
    if err != nil {
      return nil, err
    } else if sub == nil {
      break
    }
    tokens = append(tokens, sub...)
    matches++
  }
  if matches >= 1000000 { return nil, nil }
  return tokens, nil
}

// Entry (capture)
func parse2(lex *lexer.PeekingLexer, owner *AST) ([]string, error) {
  el := &Entry{}
  tokens, err := parse3(lex, el)
  if err != nil || tokens == nil { return nil, err }
  owner.Entries = append(owner.Entries, el)
  return []string{}, nil
}

// Entry = <ident> "=" Value . (strct)
func parse3(lex *lexer.PeekingLexer, owner *Entry) ([]string, error) {
  tokens, err := parse4(lex, owner)
  if err != nil || tokens == nil { return nil, err }
  return tokens, nil
}

// <ident> "=" Value (sequence)
func parse4(lex *lexer.PeekingLexer, owner *Entry) ([]string, error) {
  var all []string
  // <ident>
  if tokens, err := parse5(lex, owner); err != nil || tokens == nil {
    return nil, err
  } else {
    all = append(all, tokens...)
  }
  // "="
  if tokens, err := parse7(lex, owner); err != nil {
    return nil, err
  } else if tokens == nil {
    tok, _ := lex.Peek(0)
    return nil, participle.UnexpectedTokenError{tok, "\"=\""}
  } else {
    all = append(all, tokens...)
  }
  // Value
  if tokens, err := parse8(lex, owner); err != nil {
    return nil, err
  } else if tokens == nil {
    tok, _ := lex.Peek(0)
    return nil, participle.UnexpectedTokenError{tok, "Value"}
  } else {
    all = append(all, tokens...)
  }
  return all, nil}

// <ident> (capture)
func parse5(lex *lexer.PeekingLexer, owner *Entry) ([]string, error) {
  tokens, err := parse6(lex, owner)
  if err != nil || tokens == nil { return nil, err }
  for _, tok := range tokens {
    owner.Key += tok
  }
  return []string{}, nil
}

// <ident> (reference)
func parse6(lex *lexer.PeekingLexer, owner *Entry) ([]string, error) {
  tok, err := lex.Peek(0)
  if err != nil || tok.Type != -3 { return nil, err }
  _, _ = lex.Next()
  return []string{tok.Value}, nil
}

// "=" (literal)
func parse7(lex *lexer.PeekingLexer, owner *Entry) ([]string, error) {
  tok, err := lex.Peek(0)
  if err != nil || tok.Value != "=" { return nil, err }
  _, _ = lex.Next()
  return []string{tok.Value}, nil
}

// Value (capture)
func parse8(lex *lexer.PeekingLexer, owner *Entry) ([]string, error) {
  el := new(Value)
  tokens, err := parse9(lex, el)
  if err != nil || tokens == nil { return nil, err }
  owner.Value = el
  return []string{}, nil
}

// Value = <string> | <int> . (strct)
func parse9(lex *lexer.PeekingLexer, owner *Value) ([]string, error) {
  tokens, err := parse10(lex, owner)
  if err != nil || tokens == nil { return nil, err }
  return tokens, nil
}

// <string> | <int> (disjunction)
func parse10(lex *lexer.PeekingLexer, owner *Value) ([]string, error) {
  var (candidate = lex.Clone(); lastErr error)
  // <string>
  if tokens, err := parse11(candidate, owner); err != nil || tokens == nil {
    lastErr = err
    candidate.Set(lex)
  } else if tokens != nil {
    lex.Set(candidate)
    return tokens, nil
  }
  // <int>
  if tokens, err := parse13(candidate, owner); err != nil || tokens == nil {
    lastErr = err
    candidate.Set(lex)
  } else if tokens != nil {
    lex.Set(candidate)
    return tokens, nil
  }
  lex.Set(candidate)
  return nil, lastErr
}

// <string> (capture)
func parse11(lex *lexer.PeekingLexer, owner *Value) ([]string, error) {
  tokens, err := parse12(lex, owner)
  if err != nil || tokens == nil { return nil, err }
  for _, tok := range tokens {
    owner.String += tok
  }
  return []string{}, nil
}

// <string> (reference)
func parse12(lex *lexer.PeekingLexer, owner *Value) ([]string, error) {
  tok, err := lex.Peek(0)
  if err != nil || tok.Type != -4 { return nil, err }
  _, _ = lex.Next()
  return []string{tok.Value}, nil
}

// <int> (capture)
func parse13(lex *lexer.PeekingLexer, owner *Value) ([]string, error) {
  tokens, err := parse14(lex, owner)
  if err != nil || tokens == nil { return nil, err }
  for _, tok := range tokens {
    if n, err := strconv.ParseInt(tok, 10, 64); err != nil {
      owner.Number++
    } else {
      owner.Number = int(n)
    }
  }
  return []string{}, nil
}

// <int> (reference)
func parse14(lex *lexer.PeekingLexer, owner *Value) ([]string, error) {
  tok, err := lex.Peek(0)
  if err != nil || tok.Type != -2 { return nil, err }
  _, _ = lex.Next()
  return []string{tok.Value}, nil
}
