// Code generated by Participle. DO NOT EDIT.
{{if .Tags}}//go:build {{.Tags}}
{{end}}

package {{.Package}}

import (
	"fmt"
	"io"
	"strings"
	"sync"
	"unicode/utf8"
	"regexp/syntax"

	"github.com/alecthomas/participle/v2"
	"github.com/alecthomas/participle/v2/lexer"
)

var _ syntax.Op
var _ fmt.State
const _ = utf8.RuneError

var {{.Name}}BackRefCache sync.Map
var {{.Name}}Lexer lexer.Definition = lexer{{.Name}}DefinitionImpl{}

type lexer{{.Name}}DefinitionImpl struct {}

func (lexer{{.Name}}DefinitionImpl) Symbols() map[string]lexer.TokenType {
	return map[string]lexer.TokenType{
{{- range $sym, $rn := .Def.Symbols}}
      "{{$sym}}": {{$rn}},
{{- end}}
	}
}

func (lexer{{.Name}}DefinitionImpl) LexString(filename string, s string) (lexer.Lexer, error) {
	return &lexer{{.Name}}Impl{
		s: s,
		pos: lexer.Position{
			Filename: filename,
			Line:     1,
			Column:   1,
		},
		states: []lexer{{.Name}}State{ {name: "Root"} },
	}, nil
}

func (d lexer{{.Name}}DefinitionImpl) LexBytes(filename string, b []byte) (lexer.Lexer, error) {
	return d.LexString(filename, string(b))
}

func (d lexer{{.Name}}DefinitionImpl) Lex(filename string, r io.Reader) (lexer.Lexer, error) {
	s := &strings.Builder{}
	_, err := io.Copy(s, r)
	if err != nil {
		return nil, err
	}
	return d.LexString(filename, s.String())
}

type lexer{{.Name}}State struct {
	name    string
	groups  []string
}

type lexer{{.Name}}Impl struct {
	s       string
	p       int
	pos     lexer.Position
	states  []lexer{{.Name}}State
}

func (l *lexer{{.Name}}Impl) Next() (lexer.Token, error) {
	if l.p == len(l.s) {
		return lexer.EOFToken(l.pos), nil
	}
	var (
		state = l.states[len(l.states)-1]
		groups []int
		sym lexer.TokenType
	)
	switch state.name {
{{- range $state := .Def.Rules|OrderRules}}
	case "{{$state.Name}}":
{{- range $i, $rule := $state.Rules}}
		{{- if $i}} else {{end -}}
{{- if .Pattern -}}
		if match := match{{$.Name}}{{.Name}}(l.s, l.p, l.states[len(l.states)-1].groups); match[1] != 0 {
			sym = {{index $.Def.Symbols .Name}}
			groups = match[:]
{{- else if .|IsReturn -}}
		if true {
{{- end}}
{{- if .|IsPush}}
			l.states = append(l.states, lexer{{$.Name}}State{name: "{{.|IsPush}}"{{if HaveBackrefs $.Def $state.Name}}, groups: l.sgroups(groups){{end}}})
{{- else if (or (.|IsPop) (.|IsReturn))}}
			l.states = l.states[:len(l.states)-1]
{{- if .|IsReturn}}
			return l.Next()
{{- end}}
{{- else if not .Action}}
{{- else}}
		Unsupported action {{.Action}}
{{- end}}
		}
{{- end}}
{{- end}}
	}
	if groups == nil {
		sample := []rune(l.s[l.p:])
		if len(sample) > 16 {
			sample = append(sample[:16], []rune("...")...)
		}
		return lexer.Token{}, participle.Errorf(l.pos, "invalid input text %q", string(sample))
	}
	pos := l.pos
	span := l.s[groups[0]:groups[1]]
	l.p = groups[1]
	l.pos.Advance(span)
	return lexer.Token{
		Type:  sym,
		Value: span,
		Pos:   pos,
	}, nil
}

func (l *lexer{{.Name}}Impl) sgroups(match []int) []string {
	sgroups := make([]string, len(match)/2)
	for i := 0; i < len(match)-1; i += 2 {
		sgroups[i/2] = l.s[l.p+match[i]:l.p+match[i+1]]
	}
	return sgroups
}
