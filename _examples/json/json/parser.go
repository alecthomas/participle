// Code generated by antlr2participle. DO NOT EDIT.
package json

import (
	"github.com/alecthomas/participle/v2"
	"github.com/alecthomas/participle/v2/lexer"
)

var (
	Rules = lexer.Rules{
		"Root": {
			{"STRING", `"(\\(["\\/bfnrt]|u[0-9a-fA-F][0-9a-fA-F][0-9a-fA-F][0-9a-fA-F])|[^"\\\x{0000}-\x{001F}])*"`, nil},
			{"NUMBER", `-?(0|[1-9][0-9]*)(\.[0-9]+)?([Ee][+\-]?(0|[1-9][0-9]*))?`, nil},
			{"ws", `[ \t\n\r]+`, nil},
			{"XXX__LITERAL_Comma", `,`, nil},
			{"XXX__LITERAL_Colon", `:`, nil},
			{"XXX__LITERAL_Lbkt", `\[`, nil},
			{"XXX__LITERAL_Rbkt", `\]`, nil},
			{"XXX__LITERAL_False", `false`, nil},
			{"XXX__LITERAL_Null", `null`, nil},
			{"XXX__LITERAL_True", `true`, nil},
			{"XXX__LITERAL_Lbrc", `\{`, nil},
			{"XXX__LITERAL_Rbrc", `\}`, nil},
		},
	}
	Lexer  = lexer.MustStateful(Rules, lexer.MatchLongest())
	Parser = participle.MustBuild(
		&Json{},
		participle.Lexer(Lexer),
		participle.UseLookahead(2),
	)
)

type Json struct {
	Value *Value `@@`
}
type Obj struct {
	Pair []*Pair `'{' @@ ( ',' @@ )* '}' | '{' '}'`
}
type Pair struct {
	String *string `@STRING`
	Value  *Value  `':' @@`
}
type Arr struct {
	Value []*Value `'[' @@ ( ',' @@ )* ']' | '[' ']'`
}
type Value struct {
	String *string `@STRING`
	Number *string `| @NUMBER`
	Obj    *Obj    `| @@`
	Arr    *Arr    `| @@`
	True   bool    `| @'true'`
	False  bool    `| @'false'`
	Null   bool    `| @'null'`
}
